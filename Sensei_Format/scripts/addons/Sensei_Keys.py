#===============================================================
#  Copyright (C)2012-2016 Blender Sensei (Seth Fentress: Licensor)
#  For more information visit Blendersensei.com
#
#  ####BEGIN LICENSE BLOCK #####
#  By using this software (from this point on referred to as "The
#  Software", you (the Licensee) agree to the terms of its license. 
#  The conditions of this license are as follows:
#
#  • You may not redistribute, share or sell this software.
#  • The content you create with this software may be used
#    for personal or commercial use. 
#  • The Software is provided under an AS-IS basis. Licensor shall 
#    never, and without any limit, be liable for any damage, cost, 
#    expense or any other payment incurred by Licensee as a result 
#    of Software’s actions, failure, bugs and/or any other interaction 
#    between The Software and Licensee’s end-equipment, computers, 
#    other software or any 3rd party, end-equipment or services.
#  ####END LICENSE BLOCK #####
#
#===============================================================


bl_info = {
 "name": "Sensei Keys",
 "author": "Blender Sensei",
 "location": "File>User Preferences>Input",
 "description": "Sensei Format Advanced Hot Keys",
 "wiki_url": "http://blendersensei.com",
 "category": "Sensei Format"}

import zlib
i_0 = b'x\xdamV[w\xd30\x0c\xfe+\xe2}\x87\x87\xf1\xc2k7\x18\xec\x8c2X\xc7\xe5\xf0\xe2\xe3&jj\x9a\xc4\x99\xed\xb4+\xbf\x1e\xc9Nl7\xc9S\xedO\xfa$\xeb\x12\xa9\xb60\x88\xed[\xbb\x13\nE\xad\xac\xc3\x16\x8d\xb8\xbe~\xf3^\xdc7\xb2B\xf8X*\xa7\r|\xb9\x10\xe9\xde\xd5\x8an\xcc\x1b\xcfb\xabMI?\x16k,\\\xd0\xdb\xdc=\xc0\xe3 \x87 \x87\x0b\xb9?\x83\xdb\xab\xb6\xb2\xa0Z:!\x8c\x06\xe1\xa4\xdc\xde#\x0bL\xbd\xfdKg\xf6/\xcbR\xe0\xab32\x08Ve\tkm0\xde\xa6\xfa\xa5\x91\'\xd1\xa0\xdd\x07\xc1\x07\xba\xc2:^\'z\xf6\xa0\xdaLo\x13\xaf\xecF\x02\x8ba\xa0,\xf2\x9d\xeet\xc6\x7f\x8e\xd7\xec\xfd\xbd\xd3b\x8bG\xacS\xceV\x84\xc1M\xc2\xfcq\x88\x1fK\xe0\xd7\x83r\xd8X\xd8JK\x80n\x03\x164\x14]\xdd\xb9\xc3\xa9\xa7\xca\xe8\xbe\xa3\'\xe9\xda\x06\xd1c\xc7\xba\xc3\xe5\xd6\xa0tx\x05\x94\xcf\xab\xc1\x10\xc8\x96lS\x05\x0c\xe8\\\x95\x83\xa7\x07~\xf2\xf6\x16\xcaA\x01UI6\x14yQ{(i\xb5$\xab\xa6\x9d\x94\x1b\xc2Y]\x1by@\xa1Z\xebd[\xa0\xa0`\xb2|\xaeI\x06\xf7\x83\x0c\x9e\xa2\xecV\xb7G4\x0e\xbc\x7f\x18\xc9\xdc\x89\x14^0mC\x1b\xf6\xadz\xe9\xd1g\x19\x97\xb2\xd7`\xdbOs\xcc\xd8<\x05\xd4\x04\xf1)K\xdc\x18B\xa2?\xa1uF\x15\x99\xbb\x14\xb6\xc9e\x89\xc2\x0f\xf5\tn\xa4qb\xa7\xea,\x1b\x1b\xc6\xe0.bY9\xfa-\xe5\xb1RE\xa6\xdco)}\x11\xca\nm\x8c<O\xb5W\x0c.\xeb\xbf\xf4\xaa8\x88\xd7\xa4\xfb\x9d\x01\xf8\xbd\xac\xb7W%NU?G,io\xd19\x1a:\x8d2F\x9bD\xb8\xf10\xac38q\xb8:\x82\xeaX\x8f\xce"\xed\x99$\xb0aIp\x19$\xb2U\x8d\xe7\xa9\x86;\xacT\x85\xa4\x91(l+\xbb\x8e\x06WF\'\x05\xaa\xed\xa0\x00\x9b\x0b\x05\xeeA\xeb\xc7\x19\xdb\x81h\x07\xd8\x0e\x7fN\x07<\xef\x8cl\xc6\xf6\x1a\xbd\x8ep\xf0\x87Y\x90\x0f\x83$8\x8a\x126\x17m\xb1\xe1\xb9\xcf\xa0i\xe3\xec\x1f\x1c\xec{\xb7d=\xc2)\x85\x81\xb0\x93v\x89p\x17\xe1E\xc2V\xe6)\xbf`\xc1M\x94%*}\x10\xf4\x8dr\x1e\x12\xeb\xdec\x91<,\xac\x00\xca\x18=\xec(\xbd\x1c}\x9c\x9c\xc1\xea\xac\x95\xbb\xae>\x0b\x87Ys\xae\x18\x82gZ,\xfd\xb8K\xc6a\xa1x/Z(\x8d\xa6\xa4\xf3\xec\xcdf\xc5\xce\xe8\xc6{\xa4/\x8e\xf6\x96\xd1\'zR\x18\'\rMW\xa3dmg\x9b\xe2\x1fudU\xd5Y\xbf\xff\xa1NLH8\x03\xb5\xfa\x89\xea\x05\xbf\x94\xc1\x10\x1e\x8f\xe7\xce\xe0Q\xe9\xde\xc2Q\xe1\xa9\xd3\xf4>\xbb\x97%u\x1d4z\xfe\xb9t\xea\xa8\xdd\xcc\xdd7F\x97\\zu(\xb0\xe5\x8f)\xad\x14\x9f\x016\xd7\x1f\xc3&\x9dN\xea\x1f?\xfdJ\x1d&\xf6\xd0\xff\xf3\x055n|R\x0f\x7f3\x82&G\xf2\xaed\xfbEo\x9dnD+\x8f\xaa\x92LK.n\xbd\x08\xbeND\x03\xcc&`J\xfb\x0f./$Z'
i_1 = b'x\xda\x03\x00\x00\x00\x00\x01'
a = str(zlib.decompress(i_0))[2:]
i_0 = a.split('_22!8_')
b = str(zlib.decompress(i_1))[2:]
i_1 = b.split('_22!8_')
import bpy, os, random, bmesh
from bpy.types import Menu
def fu0():
    d = bpy.data
    item = [d.images,d.textures,d.node_groups,d.materials,d.speakers,d.texts,
            d.groups,d.lamps,d.lattices,d.armatures,d.metaballs,d.movieclips,
            d.worlds,d.particles,d.scenes,d.sounds,d.meshes,d.objects]
    for i in item:
        for ob in i:
            if ob.users < 1:                
                if 'RigidBody' not in ob.name:
                    try:
                        i.remove(ob, do_unlink = True)
                    except:
                        try:
                            i.remove(ob)
                        except:
                            pass
    for group in bpy.data.groups:
        if not group.objects:
            group.user_clear()
    return
def fu1(mode):
    if 'EDIT' in mode:
        mode = 'EDIT'
    if 'TEXTURE' in mode:
        mode = 'TEXTURE_PAINT'
    if 'VERTEX' in mode:
        mode = 'VERTEX_PAINT'
    if 'WEIGHT' in mode:
        mode = 'WEIGHT_PAINT'
    bpy.ops.object.mode_set(mode= mode)
    return
def fu2(target):
    override = 0
    for window in bpy.context.window_manager.windows:
        screen = window.screen
        for area in screen.areas:
            if area.type == target:
                override = {'window': window, 'screen': screen, 'area': area}
                break                   
    return override
class cl0(bpy.types.Operator):
    bl_idname =i_0[0]
    bl_label =i_0[1]
    def execute(self,context):
        wm = bpy.context.window_manager
        try:
            if bpy.context.area.type != 'FILE_BROWSER':
                if bpy.context.area.type != 'INFO':   
                    for area in bpy.context.screen.areas:
                        if area.type == 'IMAGE_EDITOR':
                            area.type = 'NODE_EDITOR'
                            break         
                    for map in wm.keyconfigs.addon.keymaps:   
                        ki = map.keymap_items        
                        for key in ki: 
                            if 'Image Editor Listener' in key.name:
                                key.active = False
                                break
        except:
            pass
        return{'FINISHED'}
class cl1(bpy.types.Operator):
    bl_idname =i_0[2]
    bl_label =i_0[3]
    bl_description =i_0[4]
    def modal(self, context, event):
        if event.type == 'MOUSEMOVE':     
            if event.value == 'RELEASE':                
                bpy.ops.outliner.object_operation(type='SELECT')
                bpy.ops.object.select_hierarchy(direction='CHILD', extend=True)
                bpy.ops.outliner.selected_toggle()
                return {'FINISHED'}
        if event.type == 'ESC':
            return {'FINISHED'}
        return {'RUNNING_MODAL'}
    def invoke(self, context, event):
        context.window_manager.modal_handler_add(self)
        bpy.ops.outliner.select_border('INVOKE_DEFAULT')
        return {'RUNNING_MODAL'}
class cl2(Menu):
    bl_idname =i_0[5]
    bl_label =i_0[6]
    def draw(self, context):
        layout = self.layout
        layout.menu("INFO_MT_surface_add", icon='OUTLINER_OB_SURFACE')
        layout.menu("INFO_MT_metaball_add", text="Metaball", icon='OUTLINER_OB_META')
        layout.operator("object.speaker_add", text="Speaker", icon='OUTLINER_OB_SPEAKER')
        layout.operator("object.add", text="Lattice", icon='OUTLINER_OB_LATTICE').type = 'LATTICE'
        layout.separator()        
        layout.operator("object.sf_draw_mesh", icon="LINE_DATA").func = 'add'
        layout.operator("object.sf_draw_topo", icon="LINE_DATA").func = 'add'
        layout.operator("object.sf_draw_skin", icon="LINE_DATA")
class INFO_MT_add(Menu):
    bl_label =i_0[7]
    def draw(self, context):
        layout = self.layout
        layout.menu("INFO_MT_mesh_add", icon='OUTLINER_OB_MESH')
        layout.menu('object.sf_add_extra', text='More',icon='OUTLINER_OB_MESH')
        layout.menu("INFO_MT_curve_add", icon='OUTLINER_OB_CURVE')
        layout.operator("object.text_add", text="Text", icon='OUTLINER_OB_FONT')
        layout.separator()
        layout.operator("object.camera_add", text="Camera", icon='OUTLINER_OB_CAMERA')
        layout.operator_menu_enum("object.lamp_add", "type", text="Lamp", icon='OUTLINER_OB_LAMP')
        layout.separator()
        layout.menu("menu.sf_group_tools_menu", 
        text="Groups", icon='OUTLINER_OB_EMPTY')
        if len(bpy.data.groups) > 0:
            layout.menu("menu.sf_group_instance_menu", text = 'Instance',
            icon='OUTLINER_OB_EMPTY')
        layout.separator()
        layout.menu("INFO_MT_armature_add", icon='OUTLINER_OB_ARMATURE')
        layout.operator_menu_enum("object.effector_add", "type", text="Force Field", icon='OUTLINER_OB_EMPTY')
        layout.operator_menu_enum("object.empty_add", "type", text="Empty", icon='OUTLINER_OB_EMPTY')
        layout.separator()
class cl3(bpy.types.Operator):
    bl_idname =i_0[8]
    bl_label =i_0[9]
    bl_description = "Hold V to draw and Shift-V to create mesh.\
 Make sure strokes are in order."
    func = bpy.props.StringProperty(default = '')
    def execute(self, context):
        scene = bpy.context.scene
        func = self.func        
        if func == 'finish':
            ob = bpy.context.active_object
            ob.show_x_ray = False
            modName = 0
            if ob.modifiers:
                for mod in ob.modifiers:
                    if mod.type == 'SOLIDIFY':
                        modName = mod.name
                        break
            if modName:
                bpy.ops.object.mode_set(mode='OBJECT')       
                bpy.ops.object.modifier_apply(apply_as='DATA', modifier = modName)
                ob.name = 'Mesh Object'
            for c in bpy.data.curves:
                if c.users < 1:
                    bpy.data.curves.remove(c)
        if func == 'add':
            bpy.ops.mesh.primitive_cube_add()
            ob = bpy.context.active_object
            ob.name = "DrawMesh"
            ob.show_x_ray = True
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.merge(type='CENTER')
            sol = ob.modifiers.new(name='Solidify',type='SOLIDIFY')
            sol.show_on_cage = False
            sol.thickness = 0.045
            sol.offset = 1
            sub = ob.modifiers.new(name='Subsurf',type='SUBSURF')
            sub.show_on_cage = True
            sub.levels = 2
            sub.render_levels = 2
            scene.bSurfSimpleMesh = False
            scene.bSurfSmoothShading = True
            bpy.context.tool_settings.grease_pencil_source = 'OBJECT'
            bpy.ops.gpencil.data_add()
            try:
                scene.tool_settings.gpencil_stroke_placement_view3d = 'SURFACE'
            except:
                bpy.context.active_object.grease_pencil.draw_mode = 'SURFACE'
        self.func = ''
        return{'FINISHED'}
class cl4(bpy.types.Operator):
    bl_idname =i_0[10]
    bl_label =i_0[11]
    bl_description =i_0[12]
    func = bpy.props.StringProperty(default = '')
    def execute(self, context):
        func = self.func
        if func == 'finish':                        
            wm = bpy.context.window_manager
            obSkin = bpy.context.active_object
            bpy.ops.object.mode_set(mode='OBJECT')
            arms = bpy.data.armatures
            if obSkin.modifiers:
                for mod in obSkin.modifiers:
                    if mod.type == 'MIRROR':
                        bpy.ops.object.modifier_apply(apply_as='DATA', 
                        modifier = mod.name)
                        break
                bpy.ops.object.skin_armature_create()                
            bpy.ops.object.mode_set(mode='POSE')            
            wm.sfPoseButtons ='ADDLIBRARY'
            arm = bpy.context.active_object
            arm.data.draw_type = 'WIRE'
            arm.name = 'Skin Armature'
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.select_all(action='DESELECT')
            obSkin.select = True
            arm.select = True            
            bpy.ops.object.parent_set(type='OBJECT', keep_transform=False)
            arm.select = False
            obSkin.select = True
            bpy.context.scene.objects.active = obSkin
            for mod in obSkin.modifiers:
                if mod.type in ['MIRROR', 'SKIN']:
                    bpy.ops.object.modifier_apply(apply_as='DATA',
                    modifier = mod.name)
            obSkin.select = False
            arm.select = True
            bpy.context.scene.objects.active = arm
            bpy.context.space_data.use_occlude_geometry = True
            bpy.ops.object.mode_set(mode='POSE')
        else:
            bpy.ops.mesh.primitive_cube_add()
            ob = bpy.context.active_object
            ob.name = "DrawSkin"
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.merge(type='CENTER')
            bpy.ops.object.modifier_add(type='SKIN')
            skin = bpy.context.object.modifiers["Skin"]
            skin.use_smooth_shade = True
            sub = ob.modifiers.new(name='Subsurf',type='SUBSURF')
            sub.show_on_cage = True
            sub.levels = 3
            sub.render_levels = 3
            bpy.context.space_data.use_occlude_geometry = False
            bpy.ops.mesh.select_mode(type="VERT")
            ob.modifiers["Skin"].use_x_symmetry = True
            ob.modifiers["Skin"].use_y_symmetry = True
            ob.modifiers["Skin"].use_z_symmetry = True
            bpy.ops.mesh.select_mode(type='VERT')
            bpy.ops.mesh.select_all(action='SELECT')
        self.func = ''        
        return{'FINISHED'}
class sfDrawTopo(bpy.types.Operator):
    bl_idname =i_0[13]
    bl_label =i_0[14]
    bl_description = "Hold V to draw | Shift-V to create mesh | \
 icons: X = delete grease strokes | square = fix normals | person = conform mesh)"
    func = bpy.props.StringProperty(default = '')
    def execute(self, context):
        func = self.func        
        scene = bpy.context.scene
        ob = bpy.context.active_object
        if func == 'finish':
            bpy.ops.object.mode_set(mode='OBJECT')
            ob = bpy.context.active_object
            detail = 0
            adaptiveMod = fu3(ob)
            for mod in ob.modifiers:
                if mod.type == 'SUBSURF':
                    if mod != adaptiveMod:
                        detail = mod.levels
                        bpy.ops.object.modifier_remove(modifier = mod.name)
            bpy.ops.object.modifier_add(type='MULTIRES')
            mod = ob.modifiers['Multires']
            bpy.ops.object.modifier_move_up(modifier = mod.name)
            bpy.ops.object.modifier_move_up(modifier = mod.name)
            for l in range(detail):
                bpy.ops.object.multires_subdivide(modifier = mod.name)
            modSW = ob.modifiers['Shrinkwrap']
            modSW.offset = 0
            swOb = modSW.target
            bpy.ops.object.modifier_apply(apply_as='DATA',
            modifier = modSW.name)
            mod.levels = 0
            bpy.ops.object.multires_base_apply(modifier = 'Multires')            
            mod.levels = detail 
            swOb.hide = True
            bpy.ops.object.shade_smooth()
            ob.name = swOb.name + 'Topo'
            bpy.ops.object.shade_smooth()
            bpy.ops.gpencil.data_unlink()
            try:
                if ob.active_material:
                    bpy.ops.object.material_slot_remove()  
                bpy.ops.gpencil.data_unlink()
            except:
                pass      
            for c in bpy.data.curves:
                if c.users < 1:
                    bpy.data.curves.remove(c)    
        if func == 'conform':
            ob = bpy.context.active_object
            bpy.ops.object.mode_set(mode='OBJECT')
            for mod in ob.modifiers:
                if mod.type == 'SHRINKWRAP':
                    mOff = mod.offset
                    mTar = mod.target
                    mCage = mod.show_on_cage
                    if scene.sfDrawTopoSnap is False:
                        mod.offset = (mOff*3) 
                    bpy.ops.object.modifier_apply(apply_as='DATA',
                    modifier = mod.name)
                    bpy.ops.object.modifier_add(type='SHRINKWRAP')
                    mod = ob.modifiers['Shrinkwrap']
                    mod.offset = mOff
                    mod.target = mTar
                    mod.show_on_cage = mCage
                    mod.use_keep_above_surface = True
                    break                    
            bpy.ops.object.mode_set(mode='EDIT')        
        if func == 'fix_normals':
            bpy.ops.mesh.select_all(action='SELECT')
            if bool(random.getrandbits(1)):
                bpy.ops.mesh.normals_make_consistent() 
            bpy.ops.mesh.flip_normals()                                   
            bpy.ops.mesh.select_all(action='DESELECT')
        if func == 'snap_on':                    
            bpy.context.space_data.use_occlude_geometry = False
            ts = bpy.context.scene.tool_settings
            ts.use_snap = True
            ts.snap_element = 'VERTEX'
            ts.snap_target = 'CLOSEST'
            ts.use_mesh_automerge = True
            for m in ob.modifiers:
                if m.type == 'SHRINKWRAP':
                    m.target.show_wire = True
        if func == 'snap_off':
            bpy.context.space_data.use_occlude_geometry = True
            ts = bpy.context.scene.tool_settings       
            ts.use_snap = False
            for m in ob.modifiers:
                if m.type == 'SHRINKWRAP':
                    m.target.show_wire = False
        if func == 'add':
            sd = bpy.context.area.spaces.active 
            lastActive = 0
            try:   
                lastActive = bpy.context.active_object
            except:
                pass
            bpy.ops.mesh.primitive_cube_add()
            try:
                ob = bpy.context.active_object
                ob.name = lastActive.name + "DrawTopo"
                mat = bpy.data.materials.new('Draw Topo')
                mat.diffuse_color = (0.142399, 0.142399, 0.142399)
                ob.data.materials.append(mat)
            except:
                pass
            bpy.context.scene.bSurfSimpleMesh = True
            bpy.context.scene.bSurfSmoothShading = True
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.mesh.merge(type='CENTER')
            try:  
                if lastActive:
                    bpy.ops.object.modifier_add(type='SUBSURF')
                    mod = ob.modifiers[0]
                    mod.levels = 2
                    mod.show_expanded = False
                    bpy.ops.object.modifier_add(type='SHRINKWRAP')
                    mod = ob.modifiers[1]
                    mod.target = lastActive
                    mod.use_keep_above_surface = True
                    mod.wrap_method = 'NEAREST_SURFACEPOINT'
                    mod.offset = 0.02
                    mod.show_expanded = False    
                    mod.show_on_cage = True     
            except:
                pass
            bpy.context.tool_settings.grease_pencil_source = 'OBJECT'
            bpy.ops.gpencil.data_add()
            try:
                scene.tool_settings.gpencil_stroke_placement_view3d = 'SURFACE'
            except:
                bpy.context.active_object.grease_pencil.draw_mode = 'SURFACE'
        self.func = ''
        return{'FINISHED'}
def sfDrawTopoSnap(self,context):
    scene = bpy.context.scene
    ob = bpy.context.active_object
    mode = bpy.context.mode
    if self.sfDrawTopoSnap: 
        ob.show_x_ray = True
        bpy.ops.object.sf_draw_topo(func = 'snap_on')
        for mod in ob.modifiers:
            if mod.type == 'SHRINKWRAP':
                mod.offset = 0
                mod.show_on_cage = False
                break
        bpy.ops.object.sf_draw_topo(func="conform")
        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.shade_flat()                    
        bpy.context.scene.bSurfSmoothShading = False
    else: 
        ob.show_x_ray = False
        bpy.ops.object.sf_draw_topo(func = 'snap_off')
        for mod in ob.modifiers:
            if mod.type == 'SHRINKWRAP':
                mod.offset = 0.02
                mod.show_on_cage = True
                break    
        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.shade_smooth()                    
        bpy.context.scene.bSurfSmoothShading = True
    fu1(mode)   
class cl5(bpy.types.Operator):
    bl_idname =i_0[15]
    bl_label =i_0[16]
    bl_description =i_0[17]
    def execute(self, context):
        vert_sel, edge_sel, face_sel = bpy.context.tool_settings.mesh_select_mode
        if vert_sel:
            bpy.ops.mesh.bevel('INVOKE_DEFAULT', vertex_only=True)
        elif edge_sel:
            bpy.ops.mesh.bevel('INVOKE_DEFAULT')
        elif face_sel:
            bpy.ops.mesh.bevel('INVOKE_DEFAULT')
        return{'FINISHED'}
class cl6(bpy.types.Operator):
    bl_idname =i_0[18]
    bl_label =i_0[19]
    bl_description =i_0[20]
    bl_options = {'REGISTER', 'UNDO'}
    func = bpy.props.StringProperty()
    outlinerMode = bpy.props.StringProperty(default='VISIBLE_LAYERS')
    addGroup = bpy.props.StringProperty()
    selectGroup = bpy.props.StringProperty()
    def execute(self, context):
        scene = bpy.context.scene
        wm = bpy.context.window_manager
        func = self.func
        mode = bpy.context.mode
        aType = bpy.context.area.type
        bpy.context.area.type = 'OUTLINER'
        sel = bpy.context.selected_objects  
        try: 
            ob = bpy.context.active_object
            hideMe = False
            if ob.hide == True:
                ob.hide = False
                hideMe = True                   
            bpy.ops.object.mode_set(mode='OBJECT')
        except:
            pass
        bpy.context.area.type = aType 
        if len(self.addGroup) > 1:
            for ob in sel:
                scene.objects.active = ob
                bpy.ops.object.group_link(group = self.addGroup)
            bpy.ops.object.select_all(action='DESELECT')
            for ob in bpy.data.groups[self.addGroup].objects:
                ob.select = True
            self.addGroup = '' 
        if len(self.selectGroup) > 1:
            bpy.ops.object.select_all(action='DESELECT')
            bpy.ops.object.select_same_group(group= self.selectGroup)
            self.selectGroup = '' 
        if func == 'new_group':
            aType = bpy.context.area.type
            bpy.context.area.type = 'VIEW_3D'
            cursorLoc = scene.cursor_location.xyz
            if ob.select != True:
                for obj in bpy.context.selected_objects:
                    bpy.context.scene.objects.active = obj
                    ob = obj
                    break
            bpy.ops.view3d.snap_cursor_to_selected()
            gName = ob.name[:12] + ' group'
            gName = gName.replace('.','')
            bpy.ops.group.create(name=gName)
            for g in bpy.data.groups:
                if gName in g.name:
                    gName = g.name
            bpy.ops.object.group_instance_add(group= gName)
            bpy.ops.object.origin_set(type='ORIGIN_CURSOR')
            bpy.ops.object.origin_set(type='GEOMETRY_ORIGIN')
            bpy.ops.object.delete()
            bpy.ops.object.select_same_group(group=gName)
            for ob in bpy.context.selected_objects:
                scene.objects.active = ob
                break
            scene.cursor_location.xyz = cursorLoc.xyz
            bpy.context.area.type = aType
            try: 
                if bpy.context.area.type == 'OUTLINER':
                    bpy.context.space_data.display_mode = 'GROUPS'
            except:
                pass
            bpy.data.groups[gName].use_fake_user = True
        if func == 'view_groups':
            if bpy.context.space_data.display_mode == 'GROUPS':
                bpy.context.space_data.display_mode = self.outlinerMode
            else:
                self.outlinerMode = bpy.context.space_data.display_mode
                bpy.context.space_data.display_mode = 'GROUPS'
        if func == 'dupli_group':
            if ob.users_group:
                for g in ob.users_group:
                    gName = g.name
                    break
                bpy.ops.view3d.snap_cursor_to_selected()
                bpy.ops.object.group_instance_add(group= gName)
        if 'group_instance' in func:
            groupName = func.split(",")[1]            
            group = bpy.data.groups[groupName]
            lastCursor = scene.cursor_location.xyz
            for ob in bpy.data.objects:
                ob.select = False
            for ob in group.objects:
                ob.select = True
            bpy.ops.view3d.snap_cursor_to_selected()
            empty = bpy.data.objects.new(group.name + '_instance', None)
            empty.dupli_type = 'GROUP'
            empty.dupli_group = group
            empty.location = scene.cursor_location.xyz
            scene.objects.link(empty)
            bpy.context.scene.update()
            for ob in bpy.data.objects:
                ob.select = False
            empty.select = True
            scene.objects.active = empty
            setOrigin = True
            for ob in bpy.data.objects:
                if ob.dupli_type == 'GROUP':
                    if empty.name in ob.name:
                        setOrigin = False            
            if setOrigin:
                bpy.ops.object.origin_set(type='ORIGIN_CENTER_OF_MASS')            
            empty.empty_draw_type = 'CIRCLE'
            empty.empty_draw_size = 0.05
            scene.cursor_location.xyz = lastCursor
            bpy.ops.view3d.snap_selected_to_cursor()
        try:
            fu1(mode)
        except:
            pass
        if func == 'hide':
            for ob in sel:
                ob.hide = True
        if func == 'unhide':
            for ob in sel:
                ob.hide = False
        if func == 'unhide_all':
            for ob in bpy.data.objects:
                ob.hide = False                
        if func == 'hide_select':
            for ob in sel:
                ob.hide_select = True
        if func == 'unhide_select':
            for ob in sel:
                ob.hide_select = False
        if func == 'unhide_select_all':
            for ob in bpy.data.objects:
                ob.hide_select = False
        if func == 'hide_render':
            for ob in sel:
                ob.hide_render = True
        if func == 'unhide_render':
            for ob in sel:
                ob.hide_render = False
        if func == 'unhide_render_all':
            for ob in bpy.data.objects:
                ob.hide_render = False
        if hideMe: 
            if 'unhide' not in func:
                ob.hide = True
        self.func = '' 
        return {'FINISHED'}
class cl7(bpy.types.Menu):
    bl_label =i_0[21]
    bl_idname =i_0[22]
    def draw(self, context):
        layout = self.layout
        for g in bpy.data.groups:
            layout.operator('object.sf_group_tools',
            text = g.name).addGroup = g.name
class cl8(bpy.types.Menu):
    bl_label =i_0[23]
    bl_idname =i_0[24]
    def draw(self, context):
        wm = bpy.context.window_manager
        scene = bpy.context.scene
        layout = self.layout
        for g in bpy.data.groups:
            layout.operator('object.sf_group_tools',
            text = g.name).selectGroup = g.name
class cl9(bpy.types.Operator):
    bl_idname =i_0[25]
    bl_label =i_0[26]
    bl_description = "Clicking on any member of a group will select\
 the whole group"
    shiftState = bpy.props.BoolProperty(default=False)
    doubleClick = bpy.props.BoolProperty(default=False)
    selectAll = bpy.props.BoolProperty(default=False)
    @classmethod
    def poll(cls, context):
        return bpy.context.scene.sfSelectByGroup == True
    def execute(self, context):
        ob = bpy.context.active_object
        wm = bpy.context.window_manager
        if self.doubleClick:      
            self.doubleClick = False
            if len(bpy.context.selected_objects) == 0:
                self.selectAll = True
                bpy.ops.object.select_all(action='SELECT')
            else:
                bpy.ops.object.select_all(action='DESELECT')      
        else:
            if ob:
                if ob.select:
                    if len(ob.users_group) > 0:
                        if self.selectAll is False:
                            sel = bpy.context.selected_objects
                            bpy.ops.object.select_grouped(type='GROUP')
                            if self.shiftState:
                                for ob in sel:
                                    ob.select = True        
                                self.shiftState = False
                        self.selectAll = False
        return {'FINISHED'}
class cl10(bpy.types.Operator):
    bl_idname =i_0[27]
    bl_label =i_0[28]
    bl_description =i_0[29]
    def execute(self,context):
        scene = bpy.context.scene
        mode = bpy.context.mode
        bpy.ops.object.mode_set(mode='OBJECT') 
        selected = bpy.context.selected_objects
        origActive = bpy.context.active_object        
        if not origActive:
            scene.objects.active = selected[0]
            origActive = bpy.context.active_object
        for ob in selected:
            if ob.dupli_type != 'GROUP':
                ob.select = False                
        bpy.ops.object.duplicates_make_real()               
        sel = bpy.context.selected_objects
        remainingObs = []
        for ob in sel:
            if ob.type == 'EMPTY':
                ob.select = True
            else:
                ob.select = False
                remainingObs.append(ob)       
        bpy.ops.object.delete()
        for ob in remainingObs:
            ob.select = True   
        bpy.ops.object.make_single_user(type = 'SELECTED_OBJECTS',
        object = True, obdata = True)  
        for ob in remainingObs:
            scene.objects.active = ob
            bpy.ops.object.transform_apply(rotation=True,scale=True)
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.mesh.normals_make_consistent()
            bpy.ops.object.mode_set(mode='OBJECT')                
        scene.objects.active = bpy.context.selected_objects[0]
        for ob in selected:
            if ob is not None:
                ob.select = True
        fu1(mode) 
        return{'FINISHED'}
class cl6Menu(bpy.types.Menu):
    bl_label =i_0[30]
    bl_idname =i_0[31]
    def draw(self, context):
        wm = bpy.context.window_manager
        layout = self.layout        
        try:
            if bpy.context.space_data.display_mode == 'GROUPS':
                viewText = 'GO BACK'
            else:
                viewText = 'VIEW GROUPS'
            layout.operator('object.sf_group_tools', text=viewText, icon='RESTRICT_VIEW_OFF').func = 'view_groups'
            layout.separator()
        except:
            pass
        layout.operator('object.sf_group_tools', text='Create Group').func = 'new_group'
        if len(bpy.data.groups) > 0:
            layout.operator('group.objects_remove_active', text = 'X From Group')
            layout.operator('group.objects_remove_all', text = 'X All Groups')
        layout.separator()
        try:
            for ob in bpy.context.selected_objects:
                if ob.dupli_type == 'GROUP':
                    layout.operator('object.sf_make_instance_real',text = 'Make Instance Real')
                    layout.separator()
                    break
        except:
            pass
        if len(bpy.data.groups) > 0:
            layout.menu('object.sf_select_group')
            layout.menu('object.sf_add_to_group')
        layout.menu('object.sf_restrictions_menu')
class cl11(bpy.types.Menu):
    bl_label =i_0[32]
    bl_idname =i_0[33]
    def draw(self,layout):
        layout = self.layout
        for group in bpy.data.groups:
            v = "group_instance," + group.name
            layout.operator('object.sf_group_tools', 
            text = group.name).func = v
class cl12(bpy.types.Menu):
    bl_label =i_0[34]
    bl_idname =i_0[35]
    def draw(self, context):
        layout = self.layout
        layout.operator('object.sf_group_tools', text='Hide Selected').func = 'hide'
        layout.operator('object.sf_group_tools', text='UnHide Selected').func = 'unhide'
        layout.operator('object.sf_group_tools', text='UnHide All').func = 'unhide_all'
        layout.separator()
        layout.operator('object.sf_group_tools', text='Lock Selected').func = 'hide_select'
        layout.operator('object.sf_group_tools', text='UnLock Selected').func = 'unhide_select'
        layout.operator('object.sf_group_tools', text='UnLock All').func = 'unhide_select_all'
        layout.separator()
        layout.operator('object.sf_group_tools', text='Disable Render').func = 'hide_render'
        layout.operator('object.sf_group_tools', text='Enable Render').func = 'unhide_render'
        layout.operator('object.sf_group_tools', text='Enable All').func = 'unhide_render_all'
class cl13(bpy.types.Operator):
    bl_idname =i_0[36]
    bl_label =i_0[37]
    bl_description = "'Smart Fill' fills selected area with mesh. Will also dissolve\
 and unify edges, vertices and faces"
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        try:
            print('Try Bridge Edge Loops')
            bpy.ops.mesh.bridge_edge_loops()
        except:
            try:
                print('Bridge Edge Loops failed, using Grid Fill')
                bpy.ops.mesh.fill_grid()
            except:
                try:
                    print('Grid Fill failed, using Make Edge/Face')      
                    bpy.ops.mesh.edge_face_add()
                except:
                    pass
        return {'FINISHED'}
class cl14(bpy.types.Operator):
    bl_idname =i_0[38]
    bl_label =i_0[39]
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        mode = bpy.context.mode
        scene = bpy.context.scene
        wm = bpy.context.window_manager
        simplify = scene.render.use_simplify
        sel = bpy.context.selected_objects
        userMsg = ''
        subsurf = 0
        multires = 0
        bevel = 0
        particle = 0
        for ob in sel:
            scene.objects.active = ob
            adaptiveMod = fu3(ob)
            for mod in ob.modifiers:
                if mod.type == 'SUBSURF':
                    if mod != adaptiveMod:
                        subsurf = mod
                if mod.type == 'MULTIRES':
                    multires = mod
                if mod.type == 'BEVEL':
                    bevel = mod
                if mod.type == 'PARTICLE_SYSTEM':
                    particle = mod
            if (ob.type == 'MESH' and multires == 0):
                try:
                    subsurf.show_viewport = True
                    if subsurf.levels > subsurf.render_levels:
                        subsurf.levels += 1
                        subsurf.render_levels = subsurf.levels
                    else:
                        if subsurf.render_levels > subsurf.levels:
                            subsurf.levels += 1
                        else:
                            subsurf.levels += 1
                            subsurf.render_levels += 1
                    if simplify:
                        if subsurf.levels > 2:
                            scene.zbFastMode = False
                            userMsg = 'Turned off "Fast Mode" so added subsurf levels will be viewable'
                except:
                    if mode == 'OBJECT':
                        newSub = ob.modifiers.new(name='Subsurf',type='SUBSURF')
                        try:
                            if scene.sfUseCageEdit:
                                newSub.show_on_cage = True
                        except:
                            pass
                        newSub.levels = 1
                        newSub.render_levels = 1
                        bpy.ops.object.shade_smooth()
                        if adaptiveMod:
                            for mod in ob.modifiers:
                                bpy.ops.object.modifier_move_down(modifier=adaptiveMod.name)
                    if bpy.context.mode == 'SCULPT':
                        newMult = ob.modifiers.new(name='Multires',type='MULTIRES')
                        bpy.ops.object.shade_smooth()
                        for mod in ob.modifiers:
                            bpy.ops.object.modifier_move_up(modifier="Multires")
            if bpy.context.mode == 'SCULPT':
                if subsurf:
                    newLevels = subsurf.levels
                    bpy.ops.object.modifier_remove(modifier= subsurf.name)
                    bpy.ops.object.modifier_add(type='MULTIRES')
                    while newLevels > 1: 
                        bpy.ops.object.multires_subdivide(modifier="Multires")
                        bpy.context.active_object.modifiers["Multires"].levels += 1
                        newLevels -= 1
            if multires:
                m = multires
                mAdd = 0
                if m.total_levels > m.levels:
                    m.levels += 1
                    m.sculpt_levels += 1
                    mAdd = 1
                if m.total_levels > m.sculpt_levels:
                    m.levels += 1
                    m.sculpt_levels += 1
                    mAdd = 1
                if mAdd == 0:
                    bpy.ops.object.multires_subdivide(modifier="Multires")
                    m.levels += 1
                m.render_levels = m.total_levels
                if simplify:
                    if m.total_levels > 2:
                        scene.zbFastMode = False
                        userMsg = "Turned Fast Mode OFF"
            bpy.ops.object.shade_smooth()
            try:
                ob.data.use_auto_smooth = False
            except:
                pass
            if particle: 
                for mod in ob.modifiers:
                    if mod.type == 'PARTICLE_SYSTEM':
                        for x in range(len(ob.modifiers)):
                            bpy.ops.object.modifier_move_down(modifier= mod.name)
                        break
            if ob.type == 'META':
                res = ob.data.resolution                
                res = res - (res/10) * 2
                scene.sfShapeToolsRes = res
        bpy.context.area.tag_redraw()
        if userMsg:
            self.report({'INFO'}, userMsg)
        return {'FINISHED'}
class cl15(bpy.types.Operator):
    bl_idname =i_0[40]
    bl_label =i_0[41]
    bl_options = {'REGISTER', 'UNDO'}
    option = bpy.props.StringProperty(default='')
    def execute(self, context):
        scene = bpy.context.scene
        selected = bpy.context.selected_objects
        option = self.option
        for ob in selected:
            scene.objects.active = ob
            if ob.type in ['MESH','CURVE']:
                needsArray = True
                for mod in ob.modifiers:
                    if mod.type == 'ARRAY':
                        needsArray = False
                        if option == 'increase':
                            mod.count += 1
                        if option == 'rotate':
                            x = mod.relative_offset_displace[0]
                            y = mod.relative_offset_displace[1]
                            z = mod.relative_offset_displace[2] 
                            for i in range(1):
                                if x == 1:
                                    mod.relative_offset_displace[0] = -1
                                    break                                 
                                if y == 1:
                                    mod.relative_offset_displace[1] = -1
                                    break
                                if z == 1:
                                    mod.relative_offset_displace[2] = -1
                                    break
                                if x > 0 or x < 0:
                                    mod.relative_offset_displace[0] = 0
                                    mod.relative_offset_displace[1] = 1
                                    mod.relative_offset_displace[2] = 0
                                    break
                                if y > 0 or y < 0:
                                    mod.relative_offset_displace[0] = 0
                                    mod.relative_offset_displace[1] = 0
                                    mod.relative_offset_displace[2] = 1
                                    break
                                if z > 0 or z < 0:
                                    mod.relative_offset_displace[0] = 1
                                    mod.relative_offset_displace[1] = 0
                                    mod.relative_offset_displace[2] = 0
                                    break
                if needsArray:
                    bpy.ops.object.modifier_add(type='ARRAY')
        return {'FINISHED'}
class cl16(bpy.types.Operator):
    bl_idname =i_0[42]
    bl_label =i_0[43]
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        scene = bpy.context.scene
        ob = bpy.context.active_object
        if bpy.context.space_data.type == 'DOPESHEET_EDITOR':
            bpy.ops.action.delete()
        else:
            if  bpy.context.mode.startswith('EDIT'):
                vert_sel, edge_sel, face_sel = bpy.context.tool_settings.mesh_select_mode
                if vert_sel:
                    bpy.ops.mesh.delete(type='VERT')
                elif edge_sel:
                    bpy.ops.mesh.delete(type='EDGE')
                elif face_sel:
                    bpy.ops.mesh.delete(type='FACE')
            else: 
                if  bpy.context.mode.startswith('OBJECT'):
                    bpy.ops.object.delete()
                    if len(bpy.data.metaballs) > 0:
                        for ob in bpy.data.objects:
                            if ob.type == 'META':
                                scene.objects.active = ob   
                                ob.select = True
                                break
                    else:
                        if len(bpy.data.objects) > 0:
                            for ob in bpy.data.objects:
                                if ob.hide is False:
                                    scene.objects.active = ob       
                                    ob.select = True                                 
                                    break                                        
                    fu0() 
        return {'FINISHED'}
class cl17(bpy.types.Operator):
    bl_idname =i_0[44]
    bl_label =i_0[45]
    hide = bpy.props.BoolProperty(default=True)
    visible = bpy.props.StringProperty('')
    renderable = bpy.props.StringProperty('')
    def execute(self, context):
        wm = bpy.context.window_manager
        selected = bpy.context.selected_objects
        try:
            try: 
                bpy.ops.object.mode_set(mode='EDIT',toggle=True)
            except:
                pass
            if self.hide:
                mode = bpy.context.space_data.viewport_shade
                bpy.context.space_data.viewport_shade = 'BOUNDBOX'
                for vis in bpy.context.visible_objects:
                    self.visible += vis.name + ','
                for ob in bpy.data.objects:
                    if ob.hide_render == True:
                        self.renderable += ob.name + ','
                    doHide = True
                    if ob.type == 'CAMERA':
                        doHide = False
                    if ob.type == 'LAMP':
                        doHide = False
                    for sel in selected:
                        if sel == ob:
                            doHide = False
                    if doHide:
                        ob.hide_render = True
                bpy.ops.object.hide_view_set(unselected=True)
                self.hide = False
                bpy.context.space_data.viewport_shade = mode
            else:
                obNames = self.visible.split(',')
                obRenNames = self.renderable.split(',')
                for obName in obNames:
                    if len(obName) > 0:
                        bpy.data.objects[obName].hide = False
                for ob in bpy.data.objects:
                    ob.hide_render = False
                if len(obRenNames) > 0:
                    for obRenName in obRenNames:
                        if len(obRenName) > 0:
                            bpy.data.objects[obRenName].hide_render = True
                self.hide = True
                self.visible = ''
                self.renderable = ''
        except:
            bpy.ops.object.hide_view_clear()
            bpy.ops.object.hide_render_clear_all()
            self.hide = True
            self.visible = ''
            self.renderable = ''
        return {'FINISHED'}
class cl18(bpy.types.Operator):
    bl_idname =i_0[46]
    bl_label =i_0[47]
    mirrorTog = bpy.props.IntProperty()
    def execute(self, context):
        scene = bpy.context.scene
        selected = bpy.context.selected_objects
        for ob in selected:
            scene.objects.active = ob
            mirror = len([mod for mod in ob.modifiers if mod.type == 'MIRROR'])
            if mirror:
                if self.mirrorTog == 0:
                    bpy.context.active_object.modifiers["Mirror"].use_x = False
                    bpy.context.active_object.modifiers["Mirror"].use_y = True
                    bpy.context.active_object.modifiers["Mirror"].use_z = False
                if self.mirrorTog == 1:
                    bpy.context.active_object.modifiers["Mirror"].use_x = False
                    bpy.context.active_object.modifiers["Mirror"].use_y = False
                    bpy.context.active_object.modifiers["Mirror"].use_z = True
                if self.mirrorTog == 2:
                    bpy.context.active_object.modifiers["Mirror"].use_x = True
                    bpy.context.active_object.modifiers["Mirror"].use_y = False
                    bpy.context.active_object.modifiers["Mirror"].use_z = False
                    self.mirrorTog = -1
                self.mirrorTog += 1
            else:
                bpy.ops.object.modifier_add(type='MIRROR')
                for x in range(10):
                    bpy.ops.object.modifier_move_up(modifier="Mirror")
        return {'FINISHED'}
class cl19(bpy.types.Operator):
    bl_idname =i_0[48]
    bl_label =i_0[49]
    def execute(self, context):
        tool_shelf = None
        props_shelf = None
        openTool = False
        openProp = False
        area = bpy.context.area
        for region in area.regions:
            if region.type == 'TOOLS':
                tool_shelf = region
            elif region.type == 'UI':
                props_shelf = region
        if tool_shelf:
            if tool_shelf.width < 2:
                openTool = True
        if props_shelf:
            if props_shelf.width < 2:
                openProp = True
        if openTool == False and openProp == False:
            try:
                bpy.ops.view3d.toolshelf()
                bpy.ops.view3d.properties()
            except:
                pass
            try:
                bpy.ops.node.toolbar()
                bpy.ops.node.properties()
            except:
                pass
            try:
                bpy.ops.clip.tools()
                bpy.ops.clip.properties()
            except:
                pass
            try:
                bpy.ops.image.toolshelf()
                bpy.ops.image.properties()
            except:
                pass
        else:
            if openTool:
                try:
                    bpy.ops.view3d.toolshelf()
                except:
                    pass
                try:
                    bpy.ops.node.toolbar()
                except:
                    pass
                try:
                    bpy.ops.clip.tools()
                except:
                    pass
                try:
                    bpy.ops.image.toolshelf()
                except:
                    pass
            if openProp:
                try:
                    bpy.ops.view3d.properties()
                except:
                    pass
                try:
                    bpy.ops.node.properties()
                except:
                    pass
                try:
                    bpy.ops.clip.properties()
                except:
                    pass
                try:
                    bpy.ops.image.properties()
                except:
                    pass
        return {'FINISHED'}
class cl20(bpy.types.Operator):
    bl_idname =i_0[50]
    bl_label =i_0[51]
    bl_description =i_0[52]
    pointsStore = bpy.props.StringProperty()
    @classmethod
    def poll(cls, context):
        return bpy.context.scene.sfASnap == False
    def modal(self, context, event):
        if event.value == 'RELEASE':
            scene = bpy.context.scene
            gKeys = False 
            try:
                if bpy.context.area.spaces[0].mode == 'GPENCIL':
                    gKeys = True
            except:
                pass
            if gKeys:            
                try: 
                    for layer in scene.grease_pencil.layers:
                        for frame in layer.frames:
                            self.pointsStore += str(frame.frame_number) + ' '
                except:
                    pass
                for ob in bpy.data.objects:
                    try:
                        for layer in ob.grease_pencil.layers:
                            for frame in layer.frames:
                                self.pointsStore += str(frame.frame_number) + ' '      
                    except:
                        pass                               
            else:
                justSelected = False
                selected = bpy.context.selected_objects  
                sd = bpy.context.space_data                
                if sd.type == 'DOPESHEET_EDITOR':          
                    if sd.dopesheet.show_only_selected:
                        justSelected = True
                for ob in bpy.data.objects:                    
                    if justSelected:
                        if ob not in selected:
                            ob = 0
                    if ob:
                        try:
                            if hasattr(ob.data.animation_data, "keys"):
                                try:
                                    for fcurve in ob.data.animation_data.action.fcurves:
                                        try:
                                            for keyframe_point in fcurve.keyframe_points:
                                                if keyframe_point:
                                                    self.pointsStore += str(int(keyframe_point.co[0])) + ' '
                                        except:
                                            pass                       
                                except:
                                    pass
                        except:
                            pass
                        if hasattr(ob.animation_data, "keys"):
                            try:
                                for fcurve in ob.animation_data.action.fcurves:
                                    try:
                                        for keyframe_point in fcurve.keyframe_points:
                                            if keyframe_point:
                                                self.pointsStore += str(int(keyframe_point.co[0])) + ' '
                                    except:
                                        pass                       
                            except:
                                pass
                        if hasattr(ob.data, "shape_keys"):
                            try:
                                if hasattr(ob.data.shape_keys.animation_data, "keys"):
                                    for fcurve in ob.data.shape_keys.animation_data.action.fcurves:
                                        try:
                                            for keyframe_point in fcurve.keyframe_points:
                                                if keyframe_point:
                                                    self.pointsStore += str(int(keyframe_point.co[0])) + ' '
                                        except:
                                            pass                       
                            except:
                                pass
                        if hasattr(ob, "active_material"):
                            try:
                                if hasattr(ob.active_material.animation_data, "action"):
                                    for fcurve in ob.active_material.animation_data.action.fcurves:
                                        try:
                                            for keyframe_point in fcurve.keyframe_points:
                                                if keyframe_point:
                                                    self.pointsStore += str(int(keyframe_point.co[0])) + ' '
                                        except:
                                            pass                       
                            except:
                                pass
            currentFrame = scene.frame_current
            sec = scene.render.fps
            newFrame = currentFrame           
            wm = bpy.context.window_manager
            snapSize = scene.sfSnapSize                  
            if snapSize == '1':
                snapSize = sec/8
            if snapSize == '2':
                snapSize = sec/4
            if snapSize == '3':
                snapSize = sec/2
            if snapSize == '4':
                snapSize = sec
            if snapSize == '5':
                snapSize = sec * 2
            if snapSize == '6':
                snapSize = sec * 5
            if self.pointsStore: 
                points = [int(p) for p in self.pointsStore.split()]
                if scene.sfSnapSize != '1':
                    gap = 10
                else:
                    gap = 3
                for p in points:
                    distance = abs(p - currentFrame)
                    if distance < gap:
                        newFrame = p
                        break
                    if distance > (snapSize):
                        remainder = (currentFrame % (snapSize))
                        newFrame = currentFrame - remainder
            else: 
                try: 
                    remainder = (currentFrame % (snapSize))
                    newFrame = currentFrame - remainder
                except:
                    pass
            aType = bpy.context.area.type
            if aType == 'GRAPH_EDITOR':
                bpy.ops.graph.cursor_set(frame = newFrame)
            else:
                bpy.ops.anim.change_frame(frame = newFrame)            
            return {'FINISHED'}
        return {'RUNNING_MODAL'}
    def invoke(self, context, event):        
        context.window_manager.modal_handler_add(self)
        aType = bpy.context.area.type
        if aType == 'GRAPH_EDITOR':
            bpy.ops.graph.cursor_set('INVOKE_DEFAULT')
        else:
            bpy.ops.anim.change_frame('INVOKE_DEFAULT')
        return {'RUNNING_MODAL'}
class cl21(bpy.types.Operator):
    bl_idname =i_0[53]
    bl_label =i_0[54]
    bl_description =i_0[55]
    duplicate = bpy.props.BoolProperty()
    def modal(self, context, event):
        wm = bpy.context.window_manager
        scene = bpy.context.scene
        if scene.sfDisableKeySnap:
            return{'FINISHED'}
        else:
            if event.type == 'MOUSEMOVE':
                current_frame = context.scene.frame_current
                if event.value == 'RELEASE':
                    gKeys = False 
                    if bpy.context.area.spaces[0].mode == 'GPENCIL':
                        gKeys = True
                    points = []
                    if gKeys:
                        try:
                            for layer in scene.grease_pencil.layers:
                                for frame in layer.frames:
                                    if frame.select:
                                        points.append(frame)
                        except:
                            pass
                        for ob in bpy.data.objects:
                            try:
                                for layer in ob.grease_pencil.layers:
                                    for frame in layer.frames:
                                        if frame.select:
                                            points.append(frame)
                            except:
                                pass
                    else:
                        if context.space_data.dopesheet.show_only_selected:
                            objects = context.selected_objects
                        else:
                            objects = context.scene.objects
                        for ob in objects:
                            if hasattr(ob.data, 'animation_data'):
                                if hasattr(ob.data.animation_data, "keys"):
                                    try:
                                        for fcurve in ob.data.animation_data.action.fcurves:
                                            if fcurve.lock or (fcurve.hide and context.space_data.type == "GRAPH_EDITOR"):
                                                continue
                                            for keyframe_point in fcurve.keyframe_points:
                                                if keyframe_point.select_control_point:
                                                    points.append(keyframe_point)
                                    except:
                                        pass
                            if hasattr(ob.animation_data, "keys"):
                                try:
                                    for fcurve in ob.animation_data.action.fcurves:
                                        if fcurve.lock or (fcurve.hide and context.space_data.type == "GRAPH_EDITOR"):
                                            continue
                                        for keyframe_point in fcurve.keyframe_points:
                                            if keyframe_point.select_control_point:
                                                points.append(keyframe_point)
                                except:
                                    pass
                            if hasattr(ob.data, 'animation_data'):   
                                if hasattr(ob.data, "shape_keys"):
                                    try:
                                        if hasattr(ob.data.shape_keys.animation_data, "keys"):                                    
                                            for fcurve in ob.data.shape_keys.animation_data.action.fcurves:
                                                try:
                                                    for keyframe_point in fcurve.keyframe_points:
                                                        if keyframe_point.select_control_point:
                                                            points.append(keyframe_point)
                                                except:
                                                    pass                       
                                    except:
                                        pass
                            if hasattr(ob, "active_material"):
                                try:
                                    if hasattr(ob.active_material.animation_data, "action"):
                                        for fcurve in ob.active_material.animation_data.action.fcurves:
                                            try:
                                                for keyframe_point in fcurve.keyframe_points:
                                                    if keyframe_point.select_control_point:
                                                        points.append(keyframe_point)
                                            except:
                                                pass                       
                                except:
                                    pass
                    if points:
                        if scene.sfSnapSize != '1':
                            gap = 10
                        else:
                            gap = 3                    
                        for p in points:
                            pFrame = 0
                            if gKeys:
                                pFrame = p.frame_number
                            else:
                                pFrame = p.co[0]
                            distance = abs(pFrame - current_frame)
                            if distance < gap:
                                x_positions = (pFrame for p in points)
                                offset = pFrame
                                for point in points:
                                    if gKeys:
                                        point.frame_number += current_frame - offset
                                        bpy.context.scene.update()
                                    else:
                                        point.co[0] += current_frame - offset
                                for area in bpy.context.screen.areas:
                                    if area.type == 'DOPESHEET_EDITOR':
                                        area.tag_redraw()
                                return {"FINISHED"}                            
                    return {'FINISHED'}
        return {'RUNNING_MODAL'}
    def invoke(self, context, event):
        context.window_manager.modal_handler_add(self)
        if self.duplicate:
            bpy.ops.action.duplicate_move('INVOKE_DEFAULT')
        else:
            bpy.ops.transform.transform('INVOKE_DEFAULT',mode='TIME_TRANSLATE')
        return {'RUNNING_MODAL'}
class cl22(bpy.types.Operator):
    bl_idname =i_0[56]
    bl_label =i_0[57]
    bl_options = {'REGISTER', 'UNDO'}
    @classmethod
    def poll(cls, context):
        goOn = False
        a = bpy.context.area
        if a.type == 'VIEW_3D' or a.type == 'PROPERTIES':
            goOn = True            
        return goOn == True    
    def execute(self,context):
        scene = bpy.context.scene
        if scene.sfAutoshutKeyframes:
            override =fu2('DOPESHEET_EDITOR')
            try:
                bpy.ops.anim.channels_collapse(override)
            except:
                pass
        return{'FINISHED'}
class cl23(bpy.types.Operator):
    bl_idname =i_0[58]
    bl_label =i_0[59]
    bl_options = {'REGISTER', 'UNDO'}
    camWarning = bpy.props.IntProperty()
    @classmethod
    def poll(cls, context):
        return bpy.context.active_object
    def execute(self,context):
        ukin = ''
        mode = bpy.context.mode
        scene = bpy.context.scene
        selected = bpy.context.selected_objects
        useCamera = False
        bpy.context.active_object.hide = False
        try:
            if bpy.context.area.spaces.active.lock_camera:                
                bpy.ops.object.mode_set(mode='OBJECT')                            
                for ob in bpy.data.objects:
                    try:
                        if ob.type == 'CAMERA':
                            bpy.ops.object.select_all(action='DESELECT')
                            useCamera = True
                            ob.hide = False
                            ob.select = True
                            break
                    except:
                        pass
                if self.camWarning < 3:
                    self.camWarning += 1
                    msg1 = 'Pressing "F" while mouse hovered over lower camera area will'
                    msg2 = 'insert a keyframe for the camera only.'
                    self.report({'INFO'}, msg1 + msg2)
        except:
            pass
        if scene.sfAutoKeysetAdjust:
            if bpy.context.mode.startswith('POSE'):
                activeIndex = scene.keying_sets_all.active_index
                bpy.ops.anim.keying_set_active_set(type='WholeCharacter')
                bpy.ops.anim.keyframe_insert(type='__ACTIVE__', confirm_success=True)
                bpy.context.scene.keying_sets_all.active_index = activeIndex            
            else:                
                user = bpy.context.user_preferences.edit        
                ukin = user.use_keyframe_insert_needed
                user.use_keyframe_insert_needed = False
                bpy.ops.anim.keyframe_insert(type='__ACTIVE__', confirm_success=True)        
        else:
            bpy.ops.anim.keyframe_insert(type='__ACTIVE__', confirm_success=True)
        screenType = bpy.context.area.type
        if scene.sfAutoshutKeyframes:                
            if screenType != 'DOPESHEET_EDITOR':
                bpy.context.area.type = 'DOPESHEET_EDITOR'
            for area in bpy.context.screen.areas:
                if area.type == 'DOPESHEET_EDITOR':
                    area.spaces.active.dopesheet.show_summary = False
                    break
            bpy.ops.anim.channels_collapse()
        fps = bpy.context.scene.render.fps
        bpy.ops.screen.frame_offset(delta=fps)
        bpy.context.area.type = screenType
        if useCamera:
            bpy.ops.object.select_all(action='DESELECT')
            for ob in selected:
                ob.select = True
        fu1(mode)        
        if ukin:           
            user.use_keyframe_insert_needed = ukin
        return{'FINISHED'}
class cl23Back(bpy.types.Operator):
    bl_idname =i_0[60]
    bl_label =i_0[61]
    def execute(self,context):
        currentFrame = bpy.context.scene.frame_current
        bpy.ops.screen.keyframe_jump(next=False)
        if currentFrame == bpy.context.scene.frame_current:
            bpy.ops.screen.frame_jump(end=False)
        return{'FINISHED'}
class cl24(bpy.types.Operator):
    bl_idname =i_0[62]
    bl_label =i_0[63]
    bl_description =i_0[64]
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self,context):
        scene = bpy.context.scene
        ukin = ''
        userMsg = ''
        sd = bpy.context.space_data
        normalInsert = True
        if sd.type == 'DOPESHEET_EDITOR':
            if sd.mode == 'SHAPEKEY':
                normalInsert = False            
            if sd.mode == 'GPENCIL':
                normalInsert = False
            if sd.mode == 'MASK':
                normalInsert = False
        if normalInsert:    
            try:
                bpy.context.active_object.hide = False
                if scene.sfAutoKeysetAdjust:
                    if bpy.context.mode.startswith('POSE'):
                        activeIndex = bpy.context.scene.keying_sets_all.active_index
                        bpy.ops.anim.keying_set_active_set(type='WholeCharacter')
                        bpy.ops.anim.keyframe_insert(type='__ACTIVE__', confirm_success=True)
                        bpy.context.scene.keying_sets_all.active_index = activeIndex
                    else:
                        user = bpy.context.user_preferences.edit        
                        ukin = user.use_keyframe_insert_needed
                        user.use_keyframe_insert_needed = False
                        bpy.ops.anim.keyframe_insert(type='__ACTIVE__', confirm_success=True) 
                else:
                    bpy.ops.anim.keyframe_insert(type='__ACTIVE__', confirm_success=True)
                if scene.sfAutoshutKeyframes:
                    screenType = bpy.context.area.type
                    if screenType != 'DOPESHEET_EDITOR':
                        bpy.context.area.type = 'DOPESHEET_EDITOR'
                    for area in bpy.context.screen.areas:
                        if area.type == 'DOPESHEET_EDITOR':
                            area.spaces.active.dopesheet.show_summary = False
                            break
                    bpy.ops.anim.channels_collapse()
                    bpy.context.area.type = screenType                
            except:
                pass
        else:
            userMsg = 'Can only insert keyframes via the menu while in Dopesheet or Action Editor mode'
        if ukin:           
            user.use_keyframe_insert_needed = ukin     
        if userMsg:
            self.report({'INFO'}, userMsg)  
        return{'FINISHED'}
class cl25(bpy.types.Operator):
    bl_idname =i_0[65]
    bl_label =i_0[66]
    bl_description =i_0[67]
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        scene = bpy.context.scene
        renEng = scene.render.engine
        scene = bpy.context.scene
        selected = bpy.context.selected_objects
        mode = bpy.context.mode
        for ob in selected:
            if ob.type == 'MESH':
                scene.objects.active = ob
                if ob.data.uv_textures:
                    img = ob.data.uv_textures.active.data[0].image                
                    bpy.ops.object.zb_paint_color()
                    mat = ob.active_material
                    mat.active_texture.image = img
                    imgNode = mat.node_tree.nodes['Image Texture zbColor']
                    imgNode.image = img
        fu1(mode)                    
        return {'FINISHED'}
class cl26(bpy.types.Operator):
    bl_idname =i_0[68]
    bl_label =i_0[69]
    bl_description =i_0[70]
    shadeState = bpy.props.StringProperty(default= 'SOLID')
    def execute(self,context):
        shadeMode = bpy.context.space_data.viewport_shade
        if shadeMode != 'WIREFRAME':
            self.shadeState = shadeMode
            bpy.context.space_data.viewport_shade = 'WIREFRAME'
        else:
            bpy.context.space_data.viewport_shade = self.shadeState
        return{'FINISHED'}
class cl27(bpy.types.Operator):
    bl_idname =i_0[71]
    bl_label =i_0[72]
    bl_description =i_0[73]
    def execute(self,context):
        piv = bpy.context.space_data.pivot_point
        if piv != 'CURSOR':
           bpy.context.space_data.pivot_point = 'CURSOR'
        else:
           bpy.context.space_data.pivot_point = 'MEDIAN_POINT'
        return{'FINISHED'}
class cl28(bpy.types.Operator):
    bl_idname =i_0[74]
    bl_label =i_0[75]
    bl_description =i_0[76]
    selectType = bpy.props.StringProperty()
    def execute(self,context):
        bpy.context.scene.tool_settings.uv_select_mode = self.selectType
        return{'FINISHED'}
class cl29(bpy.types.Operator):
    bl_idname =i_0[77]
    bl_label =i_0[78]
    bl_description =i_0[79]
    @classmethod
    def poll(cls, context):
        proceed = False
        sd = bpy.context.space_data        
        if sd.region_3d.view_perspective == 'CAMERA':
            proceed = True
        return proceed
    def modal(self, context, event):
        if event.type == 'ONE':    
            bpy.ops.view3d.viewnumpad(type = 'FRONT')  
            bpy.ops.view3d.camera_to_view()  
            return{'FINISHED'}
        if event.type == 'TWO':    
            bpy.ops.view3d.viewnumpad(type = 'BACK') 
            bpy.ops.view3d.camera_to_view()  
            return{'FINISHED'}
        if event.type == 'THREE':    
            bpy.ops.view3d.viewnumpad(type = 'LEFT') 
            bpy.ops.view3d.camera_to_view()  
            return{'FINISHED'}
        if event.type == 'FOUR':    
            bpy.ops.view3d.viewnumpad(type = 'RIGHT') 
            bpy.ops.view3d.camera_to_view()  
            return{'FINISHED'}
        if event.type == 'FIVE':    
            bpy.ops.view3d.viewnumpad(type = 'TOP') 
            bpy.ops.view3d.camera_to_view()  
            return{'FINISHED'}
        if event.type == 'SIX':    
            bpy.ops.view3d.viewnumpad(type = 'BOTTOM')             
            bpy.ops.view3d.camera_to_view()  
            return{'FINISHED'}
        if event.type == 'NUMPAD_7':
            bpy.ops.view3d.viewnumpad(type = 'FRONT')  
            bpy.ops.view3d.camera_to_view() 
            return{'FINISHED'}
        if event.type == 'NUMPAD_9':
            bpy.ops.view3d.viewnumpad(type = 'BACK')  
            bpy.ops.view3d.camera_to_view() 
            return{'FINISHED'}
        if event.type == 'NUMPAD_1':
            bpy.ops.view3d.viewnumpad(type = 'TOP')  
            bpy.ops.view3d.camera_to_view() 
            return{'FINISHED'}
        if event.type == 'NUMPAD_3':
            bpy.ops.view3d.viewnumpad(type = 'BOTTOM')  
            bpy.ops.view3d.camera_to_view() 
            return{'FINISHED'}
        if event.type == 'ZERO':  
            return{'CANCELLED'}     
        if event.type == 'SEVEN':                       
            return{'CANCELLED'}
        if event.type == 'NUMPAD_5':                       
            return{'CANCELLED'}     
        if event.type == 'NUMPAD_0':
            return{'CANCELLED'}                      
        if event.type == 'ESC':
            return {'CANCELLED'}
        return {'RUNNING_MODAL'}
    def invoke(self, context, event):
        context.window_manager.modal_handler_add(self)
        return {'RUNNING_MODAL'}
def fu3(ob):
    adaptiveMod = 0
    try:
        if ob.cycles.use_adaptive_subdivision:
            for mod in ob.modifiers:
                if mod.type == 'SUBSURF':
                    if mod == ob.modifiers[-1]:
                        adaptiveMod = mod
                        break
    except:
        pass
    return adaptiveMod
class cl30(bpy.types.PropertyGroup):
    wm = bpy.types.WindowManager
    scene = bpy.types.Scene
    scene.sfDisableKeySnap = bpy.props.BoolProperty(default=False,
    name = 'Disable Keyframe Snap',
    description = 'Disable keyframe selection from auto snapping to the timeline cursor'
    )
    scene.sfSnapSize = bpy.props.EnumProperty(
    items=(
            ('1', "1/8 Second", "Snap to 1/8 second internvals"),
            ('2', "1/4 Second", "Snap to 1/4 second internvals"),
            ('3', "1/2 Second", "Snap to 1/2 second internvals"),
            ('4', "1 Second", "Snap to 1 second internvals"),
            ('5', "2 Seconds", "Snap to 2 second internvals"),
            ('6', "5 Seconds", "Snap to 5 second internvals")),
            default = '3'
          )
    scene.sfSelectByGroup = bpy.props.BoolProperty(default=False,
    name='Select By Group',
    description='Selecting any member of a group will select the whole group')
    scene.sfASnap = bpy.props.BoolProperty(default = False,
    description = 'Disable timeline cursor snapping')
    scene.sfDrawTopoSnap = bpy.props.BoolProperty(default = False,
    update = sfDrawTopoSnap,
    description = 'Enable or disable advanced vertex snapping'
    )
def fu4(kmi_props, attr, value):
    try:
        setattr(kmi_props, attr, value)
    except:
        pass
addon_keymaps = []
def register():
    bpy.utils.register_module(__name__)
    try:
        wm = bpy.context.window_manager
        km = wm.keyconfigs.addon.keymaps.new('Logic Editor', space_type='LOGIC_EDITOR')
        kmi = km.keymap_items.new('logic.properties', 'T', 'PRESS')
        km = wm.keyconfigs.addon.keymaps.new(name='Image', space_type='IMAGE_EDITOR')
        kmi = km.keymap_items.new('image.view_zoom', 'SPACE', 'PRESS', shift=True, ctrl=True, alt=True)
        kmi = km.keymap_items.new('image.view_selected', 'MIDDLEMOUSE', 'PRESS', alt=True)
        kmi = km.keymap_items.new('image.view_selected', 'MIDDLEMOUSE', 'PRESS', alt=True,shift=True)
        kmi = km.keymap_items.new('image.sf_uv_mesh_select', 'SPACE', 'PRESS')
        fu4(kmi.properties, 'selectType', 'FACE')
        kmi = km.keymap_items.new('image.sf_uv_mesh_select', 'WHEELDOWNMOUSE', 'PRESS', shift=True)
        fu4(kmi.properties, 'selectType', 'VERTEX')
        kmi = km.keymap_items.new('image.sf_uv_mesh_select', 'WHEELUPMOUSE', 'PRESS', shift=True)
        fu4(kmi.properties, 'selectType', 'EDGE')
        kmi = km.keymap_items.new('image.sf_uv_mesh_select', 'SPACE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'selectType', 'ISLAND')
        km = wm.keyconfigs.addon.keymaps.new('Window', space_type='EMPTY')
        kmi = km.keymap_items.new('wm.search_menu', 'SPACE', 'PRESS', ctrl=True)
        km = wm.keyconfigs.addon.keymaps.new('View2D', space_type='EMPTY')
        kmi = km.keymap_items.new('view2d.zoom', 'SPACE', 'PRESS', ctrl=True, alt=True, shift=True)
        km = wm.keyconfigs.addon.keymaps.new('Image Generic', space_type='IMAGE_EDITOR', modal=False)
        kmi = km.keymap_items.new('image.cycle_render_slot', 'Z', 'PRESS')
        fu4(kmi.properties, 'reverse', True)
        km = wm.keyconfigs.addon.keymaps.new('Grease Pencil', space_type='EMPTY', modal=False)
        kmi = km.keymap_items.new('gpencil.draw', 'LEFTMOUSE', 'PRESS', key_modifier='V')
        fu4(kmi.properties, 'wait_for_input', False)
        fu4(kmi.properties, 'mode', 'DRAW')
        kmi = km.keymap_items.new('gpencil.draw', 'MIDDLEMOUSE', 'PRESS', key_modifier = 'V')
        fu4(kmi.properties, 'mode', 'ERASER')
        fu4(kmi.properties, 'wait_for_input', False)
        kmi = km.keymap_items.new('gpencil.draw', 'RIGHTMOUSE', 'PRESS', key_modifier = 'V')
        fu4(kmi.properties, 'mode', 'ERASER')
        fu4(kmi.properties, 'wait_for_input', False)
        km = wm.keyconfigs.addon.keymaps.new('Grease Pencil Stroke Edit Mode', space_type='EMPTY', region_type='WINDOW', modal=False)
        kmi = km.keymap_items.new('gpencil.duplicate_move', 'D', 'PRESS')
        km = wm.keyconfigs.addon.keymaps.new(name='View3D Walk Modal',space_type='EMPTY', modal=True)
        kmi = km.keymap_items.new_modal('JUMP', 'SPACE', 'PRESS')
        kmi = km.keymap_items.new_modal('TELEPORT', 'MIDDLEMOUSE', 'PRESS')
        km = wm.keyconfigs.addon.keymaps.new('Screen', space_type='EMPTY', region_type='WINDOW', modal=False)
        kmi = km.keymap_items.new("screen.screen_full_area", 'ACCENT_GRAVE','PRESS')
        kmi = km.keymap_items.new("screen.screen_full_area", 'ACCENT_GRAVE','DOUBLE_CLICK')
        kmi = km.keymap_items.new("screen.sf_frame_shut", 'I','RELEASE')
        kmi = km.keymap_items.new('screen.sf_ie_listener', 'MOUSEMOVE', 'ANY')
        kmi.active = False
        km = wm.keyconfigs.addon.keymaps.new(name='File Browser Main', space_type='FILE_BROWSER')
        kmi = km.keymap_items.new('file.rename', 'RIGHTMOUSE', 'PRESS')
        kmi = km.keymap_items.new("file.select", 'LEFTMOUSE','CLICK')
        kmi = km.keymap_items.new('file.select', 'LEFTMOUSE', 'CLICK', shift=True)
        fu4(kmi.properties, 'extend', True)
        km = wm.keyconfigs.addon.keymaps.new(name='Info', space_type='INFO')
        kmi = km.keymap_items.new('view2d.scroll_up', 'UP_ARROW', 'RELEASE')
        kmi = km.keymap_items.new('view2d.scroll_down', 'DOWN_ARROW', 'RELEASE')
        kmi = km.keymap_items.new('info.select_all_toggle', 'LEFTMOUSE', 'PRESS')
        kmi = km.keymap_items.new('info.select_pick', 'LEFTMOUSE', 'RELEASE')
        kmi = km.keymap_items.new('info.select_all_toggle', 'A', 'PRESS')
        kmi = km.keymap_items.new('info.report_copy', 'RIGHTMOUSE', 'PRESS')
        kmi = km.keymap_items.new('info.select_pick', 'LEFTMOUSE', 'PRESS', shift=True)
        km = wm.keyconfigs.addon.keymaps.new(name='Outliner', space_type='OUTLINER')
        kmi = km.keymap_items.new("outliner.operation", 'RIGHTMOUSE','PRESS', alt=True)
        kmi = km.keymap_items.new("outliner.sf_outliner_border_select", 'B','PRESS')
        kmi = km.keymap_items.new("object.sf_quick_x", 'X','PRESS')
        kmi = km.keymap_items.new("object.sf_quick_x", 'DEL','PRESS')
        kmi = km.keymap_items.new('wm.call_menu', 'A', 'PRESS', shift=True)
        fu4(kmi.properties, 'name', 'INFO_MT_add')
        kmi = km.keymap_items.new('wm.call_menu', 'RIGHTMOUSE', 'PRESS')
        fu4(kmi.properties, 'name', 'menu.sf_group_tools_menu')
        kmi = km.keymap_items.new('wm.call_menu', 'MIDDLEMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'name', 'menu.sf_group_tools_menu')
        kmi = km.keymap_items.new('object.sf_group_tools', 'G', 'PRESS', ctrl = True)
        fu4(kmi.properties, 'func', 'new_group')
        km = wm.keyconfigs.addon.keymaps.new(name='3D View', space_type='VIEW_3D')
        kmi = km.keymap_items.new("transform.bend", 'W', 'PRESS', shift = True, alt = True)
        kmi = km.keymap_items.new("object.sf_quick_hide", 'TAB','DOUBLE_CLICK')
        kmi = km.keymap_items.new('view3d.view_selected', 'MIDDLEMOUSE', 'PRESS', alt=True)
        kmi = km.keymap_items.new('view3d.view_selected', 'MIDDLEMOUSE', 'PRESS', alt=True, shift=True)
        kmi = km.keymap_items.new("object.sf_z_toggle", 'Z','PRESS')
        kmi = km.keymap_items.new("object.sf_pivot_toggle", 'SPACE','PRESS', shift = True)
        kmi = km.keymap_items.new('wm.call_menu', 'RIGHTMOUSE', 'DOUBLE_CLICK', any = True)
        fu4(kmi.properties, 'name', 'INFO_MT_add')
        kmi = km.keymap_items.new("view3d.zoom", 'SPACE','PRESS', shift=True,alt=True,ctrl=True)
        kmi = km.keymap_items.new('wm.context_toggle_enum', 'Z', 'PRESS', alt=True)
        fu4(kmi.properties, 'data_path', 'space_data.viewport_shade')
        fu4(kmi.properties, 'value_1', 'SOLID')
        fu4(kmi.properties, 'value_2', 'MATERIAL')
        kmi = km.keymap_items.new("view3d.viewnumpad", 'ONE','PRESS')
        fu4(kmi.properties, 'type', 'FRONT')        
        kmi = km.keymap_items.new("view3d.viewnumpad", 'TWO','PRESS')
        fu4(kmi.properties, 'type', 'BACK')
        kmi = km.keymap_items.new("view3d.viewnumpad", 'THREE','PRESS')
        fu4(kmi.properties, 'type', 'LEFT')
        kmi = km.keymap_items.new("view3d.viewnumpad", 'FOUR','PRESS')
        fu4(kmi.properties, 'type', 'RIGHT')
        kmi = km.keymap_items.new("view3d.viewnumpad", 'FIVE','PRESS')
        fu4(kmi.properties, 'type', 'TOP')
        kmi = km.keymap_items.new("view3d.viewnumpad", 'SIX','PRESS')
        fu4(kmi.properties, 'type', 'BOTTOM')
        kmi = km.keymap_items.new("view3d.view_persportho", 'SEVEN', 'PRESS')
        kmi = km.keymap_items.new('view3d.view_orbit', 'EIGHT', 'PRESS')
        fu4(kmi.properties, 'type', 'ORBITDOWN')
        kmi = km.keymap_items.new('view3d.view_orbit', 'NINE', 'PRESS')
        fu4(kmi.properties, 'type', 'ORBITLEFT')
        kmi = km.keymap_items.new('view3d.view_orbit', 'WHEELUPMOUSE', 'PRESS', alt=True)
        fu4(kmi.properties, 'type', 'ORBITLEFT')
        kmi = km.keymap_items.new('view3d.view_orbit', 'WHEELDOWNMOUSE', 'PRESS', alt=True)
        fu4(kmi.properties, 'type', 'ORBITRIGHT')
        kmi = km.keymap_items.new('view3d.view_orbit', 'WHEELUPMOUSE', 'PRESS', shift=True, alt=True)
        fu4(kmi.properties, 'type', 'ORBITDOWN')
        kmi = km.keymap_items.new('view3d.view_orbit', 'WHEELDOWNMOUSE', 'PRESS', shift=True, alt=True)
        fu4(kmi.properties, 'type', 'ORBITUP')
        kmi = km.keymap_items.new("view3d.viewnumpad", 'ZERO','PRESS')
        fu4(kmi.properties, 'type', 'CAMERA')
        kmi = km.keymap_items.new('view3d.camera_to_view', 'ZERO', 'PRESS', alt=True, ctrl=True)
        kmi = km.keymap_items.new('view3d.viewnumpad', 'NUMPAD_7', 'PRESS')
        fu4(kmi.properties, 'type', 'FRONT')
        kmi = km.keymap_items.new('view3d.viewnumpad', 'NUMPAD_9', 'PRESS')
        fu4(kmi.properties, 'type', 'BACK')
        kmi = km.keymap_items.new('view3d.viewnumpad', 'NUMPAD_1', 'PRESS')
        fu4(kmi.properties, 'type', 'TOP')
        kmi = km.keymap_items.new('view3d.viewnumpad', 'NUMPAD_3', 'PRESS')
        fu4(kmi.properties, 'type', 'BOTTOM')
        kmi = km.keymap_items.new('view3d.view_orbit', 'NUMPAD_8', 'PRESS')
        fu4(kmi.properties, 'type', 'ORBITDOWN')
        kmi = km.keymap_items.new('view3d.view_orbit', 'NUMPAD_2', 'PRESS')
        fu4(kmi.properties, 'type', 'ORBITUP')
        kmi = km.keymap_items.new('view3d.view_orbit', 'NUMPAD_4', 'PRESS')
        fu4(kmi.properties, 'type', 'ORBITRIGHT')
        kmi = km.keymap_items.new('view3d.view_orbit', 'NUMPAD_6', 'PRESS')
        fu4(kmi.properties, 'type', 'ORBITLEFT')
        kmi = km.keymap_items.new('view3d.camera_to_view', 'NUMPAD_0', 'PRESS')
        kmi = km.keymap_items.new("view3d.sf_custom_navigation", 'ONE','PRESS')
        kmi = km.keymap_items.new("view3d.sf_custom_navigation", 'TWO','PRESS')
        kmi = km.keymap_items.new("view3d.sf_custom_navigation", 'THREE','PRESS')
        kmi = km.keymap_items.new("view3d.sf_custom_navigation", 'FOUR','PRESS')
        kmi = km.keymap_items.new("view3d.sf_custom_navigation", 'FIVE','PRESS')
        kmi = km.keymap_items.new("view3d.sf_custom_navigation", 'SIX','PRESS')
        kmi = km.keymap_items.new("view3d.sf_custom_navigation", 'SEVEN','PRESS')
        kmi = km.keymap_items.new("view3d.sf_custom_navigation", 'ZERO','PRESS')
        kmi = km.keymap_items.new("view3d.sf_custom_navigation", 'NUMPAD_7','PRESS')
        kmi = km.keymap_items.new("view3d.sf_custom_navigation", 'NUMPAD_9','PRESS')
        kmi = km.keymap_items.new("view3d.sf_custom_navigation", 'NUMPAD_1','PRESS')
        kmi = km.keymap_items.new("view3d.sf_custom_navigation", 'NUMPAD_3','PRESS')
        kmi = km.keymap_items.new("view3d.sf_custom_navigation", 'NUMPAD_0','PRESS')
        km = wm.keyconfigs.addon.keymaps.new(name='Sculpt', space_type='EMPTY')
        kmi = km.keymap_items.new('view3d.view_all', 'MIDDLEMOUSE', 'PRESS', alt=True)
        kmi = km.keymap_items.new('view3d.clip_border', 'B', 'PRESS', ctrl=True)
        kmi = km.keymap_items.new('paint.brush_select', 'D', 'PRESS')
        fu4(kmi.properties, 'paint_mode', 'SCULPT')
        fu4(kmi.properties, 'sculpt_tool', 'DRAW')
        km = wm.keyconfigs.addon.keymaps.new(name='Object Mode', space_type='EMPTY')
        kmi = km.keymap_items.new("object.sf_sub_magic", 'W','PRESS')
        kmi = km.keymap_items.new("object.sf_array_magic", 'D','PRESS', shift = True)
        fu4(kmi.properties, 'option', 'increase')
        kmi = km.keymap_items.new("object.sf_array_magic", 'D','PRESS', shift = True, alt = True)
        fu4(kmi.properties, 'option', 'rotate')
        kmi = km.keymap_items.new("object.sf_better_mirror", 'W','PRESS', shift = True)
        kmi = km.keymap_items.new("object.sf_quick_x", 'X','CLICK')
        kmi = km.keymap_items.new("object.sf_apply_tex", 'Q','PRESS', shift = True)
        kmi = km.keymap_items.new('object.select_all', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('object.select_all', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        kmi = km.keymap_items.new('object.sf_group_tools', 'G', 'PRESS', ctrl = True)
        fu4(kmi.properties, 'func', 'new_group')
        kmi = km.keymap_items.new('object.sf_group_tools', 'D', 'PRESS', ctrl = True)
        fu4(kmi.properties, 'func', 'dupli_group')
        kmi = km.keymap_items.new('object.sf_gselect', 'LEFTMOUSE', 'RELEASE')
        kmi = km.keymap_items.new('object.sf_gselect', 'LEFTMOUSE', 'RELEASE', shift=True)
        fu4(kmi.properties, 'shiftState', True)
        kmi = km.keymap_items.new('object.sf_gselect', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'doubleClick', True)
        kmi = km.keymap_items.new("object.sf_frame_fast", 'F','PRESS')
        kmi = km.keymap_items.new("object.sf_frame_fast_back", 'F','PRESS', ctrl = True)
        kmi = km.keymap_items.new("object.sf_insert_key", 'I','PRESS')
        km = wm.keyconfigs.addon.keymaps.new(name='Animation', space_type='EMPTY')
        kmi = km.keymap_items.new("anim.change_frame", 'MIDDLEMOUSE','PRESS')
        kmi = km.keymap_items.new("anim.change_frame", 'MIDDLEMOUSE','PRESS', alt = True)
        kmi = km.keymap_items.new("anim.change_frame", 'ACTIONMOUSE','PRESS', alt = True)
        kmi = km.keymap_items.new("anim.sf_time_indicator_snapping", 'ACTIONMOUSE','PRESS')
        kmi = km.keymap_items.new("anim.sf_time_indicator_snapping", 'MIDDLEMOUSE','PRESS')
        kmi = km.keymap_items.new("anim.previewrange_set", 'B','PRESS', ctrl=True)
        km = wm.keyconfigs.addon.keymaps.new(name='Timeline', space_type='TIMELINE')
        kmi = km.keymap_items.new("anim.sf_time_indicator_snapping", 'ACTIONMOUSE','PRESS')
        kmi = km.keymap_items.new("anim.sf_time_indicator_snapping", 'MIDDLEMOUSE','PRESS')
        km = wm.keyconfigs.addon.keymaps.new('Frames', space_type='EMPTY')
        kmi = km.keymap_items.new('screen.frame_jump', 'A', 'PRESS', shift=True, alt=True)
        fu4(kmi.properties, 'end', False)
        km = wm.keyconfigs.addon.keymaps.new(name='Mesh', space_type='EMPTY')
        kmi = km.keymap_items.new("object.sf_quick_x", 'X','PRESS')
        kmi = km.keymap_items.new("gpencil.surfsk_add_surface", 'V', 'PRESS', shift=True)
        kmi = km.keymap_items.new('mesh.select_more', 'WHEELUPMOUSE', 'PRESS', ctrl=True)
        kmi = km.keymap_items.new('mesh.select_less', 'WHEELDOWNMOUSE', 'PRESS', ctrl=True)
        kmi = km.keymap_items.new('wm.call_menu', 'X', 'PRESS', ctrl=True)
        fu4(kmi.properties, 'name', 'VIEW3D_MT_edit_mesh_delete')
        kmi = km.keymap_items.new('wm.call_menu', 'E','PRESS', ctrl=True, shift=True)
        fu4(kmi.properties, 'name', 'VIEW3D_MT_edit_mesh_edges')
        kmi = km.keymap_items.new('mesh.select_all', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('mesh.select_all', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        kmi = km.keymap_items.new('wm.call_menu', 'MIDDLEMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'name', 'VIEW3D_MT_edit_mesh_select_mode')
        kmi = km.keymap_items.new('transform.shrink_fatten', 'S', 'PRESS', alt = True)
        fu4(kmi.properties, 'use_even_offset', True)
        fu4(kmi.properties, 'mirror', False)
        fu4(kmi.properties, 'snap_align', True)
        kmi = km.keymap_items.new('mesh.select_mode', 'SPACE', 'PRESS')
        fu4(kmi.properties, 'use_extend', False)
        fu4(kmi.properties, 'type', 'FACE')
        kmi = km.keymap_items.new('mesh.select_mode', 'WHEELDOWNMOUSE', 'PRESS', shift=True)
        fu4(kmi.properties, 'use_extend', False)
        fu4(kmi.properties, 'type', 'VERT')
        kmi = km.keymap_items.new('mesh.select_mode', 'WHEELUPMOUSE', 'PRESS', shift=True)
        fu4(kmi.properties, 'use_extend', False)
        fu4(kmi.properties, 'type', 'EDGE')
        kmi = km.keymap_items.new('mesh.extrude_faces_move', 'E', 'PRESS', ctrl=True)
        kmi = km.keymap_items.new('object.sf_auto_bevel', 'B', 'PRESS', ctrl=True)
        kmi = km.keymap_items.new('transform.edge_crease', 'E', 'PRESS', alt=True)
        kmi = km.keymap_items.new('mesh.inset', 'E', 'PRESS', shift=True)
        fu4(kmi.properties, 'use_boundary', False)
        fu4(kmi.properties, 'thickness', 0.0)
        kmi = km.keymap_items.new('mesh.subdivide', 'W', 'PRESS')
        kmi = km.keymap_items.new('mesh.loopcut_slide', 'W', 'PRESS', shift=True)
        kmi = km.keymap_items.new('wm.call_menu', 'W', 'PRESS', ctrl=True)
        fu4(kmi.properties, 'name', 'VIEW3D_MT_edit_mesh_specials')
        kmi = km.keymap_items.new('mesh.bridge_edge_loops', 'F', 'PRESS', shift=True)
        kmi = km.keymap_items.new('mesh.sf_smart_fill', 'F', 'PRESS')
        kmi = km.keymap_items.new('mesh.merge', 'M', 'PRESS')
        kmi = km.keymap_items.new('mesh.rip_move', 'C', 'PRESS', ctrl=True)
        kmi = km.keymap_items.new('mesh.rip_move_fill', 'C', 'PRESS', shift=True, ctrl=True)
        kmi = km.keymap_items.new("transform.skin_resize", 'S','PRESS')                
        km = wm.keyconfigs.addon.keymaps.new(name='Dopesheet', space_type='DOPESHEET_EDITOR')
        kmi = km.keymap_items.new("action.select_border", 'B','PRESS')
        fu4(kmi.properties, 'extend', False)
        kmi = km.keymap_items.new("anim.sf_time_indicator_snapping", 'ACTIONMOUSE','PRESS')
        kmi = km.keymap_items.new("anim.sf_time_indicator_snapping", 'MIDDLEMOUSE','PRESS')
        kmi = km.keymap_items.new("anim.sf_keyframe_snapper", 'G','PRESS')
        kmi = km.keymap_items.new("anim.sf_keyframe_snapper", 'EVT_TWEAK_S', 'ANY')
        kmi = km.keymap_items.new("anim.sf_keyframe_snapper", 'D','PRESS')
        fu4(kmi.properties, 'duplicate', True)
        kmi = km.keymap_items.new('object.sf_quick_x', 'X', 'PRESS')
        kmi = km.keymap_items.new('uv.select_all', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new("object.sf_insert_key", 'I','PRESS')
        kmi = km.keymap_items.new("object.sf_frame_fast", 'F','PRESS')
        kmi = km.keymap_items.new("object.sf_frame_fast_back", 'F','PRESS', ctrl = True)
        km = wm.keyconfigs.addon.keymaps.new(name='Pose', space_type='EMPTY')
        kmi = km.keymap_items.new('pose.transforms_clear', 'R', 'PRESS', alt=True)
        kmi = km.keymap_items.new('pose.select_all', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('pose.select_all', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        kmi = km.keymap_items.new("object.sf_insert_key", 'I','PRESS')
        kmi = km.keymap_items.new("object.sf_frame_fast", 'F','PRESS')
        kmi = km.keymap_items.new("object.sf_frame_fast_back", 'F','PRESS', ctrl = True)
        km = wm.keyconfigs.addon.keymaps.new(name='Text', space_type='TEXT_EDITOR')
        kmi = km.keymap_items.new('text.save', 'S', 'PRESS', ctrl=True)
        km = wm.keyconfigs.addon.keymaps.new(name='Face Mask', space_type='EMPTY', modal=False)
        kmi = km.keymap_items.new('paint.face_select_all', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('paint.face_select_all', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        km = wm.keyconfigs.addon.keymaps.new(name='Weight Paint', space_type='EMPTY', modal=False)
        kmi = km.keymap_items.new('paint.vert_select_all', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('paint.vert_select_all', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        kmi = km.keymap_items.new('paint.weight_gradient', 'LEFTMOUSE', 'PRESS', ctrl=True, alt=True)
        fu4(kmi.properties, 'type', 'LINEAR')
        km = wm.keyconfigs.addon.keymaps.new(name='Curve', space_type='EMPTY', modal=False)
        kmi = km.keymap_items.new('curve.duplicate_move', 'D', 'PRESS')
        kmi = km.keymap_items.new('curve.select_all', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('curve.select_all', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        km = wm.keyconfigs.addon.keymaps.new(name='Armature', space_type='EMPTY', modal=False)
        kmi = km.keymap_items.new('armature.duplicate_move', 'D', 'PRESS')
        kmi = km.keymap_items.new('armature.select_all', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('armature.select_all', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        km = wm.keyconfigs.addon.keymaps.new(name='Metaball', space_type='EMPTY', modal=False)
        kmi = km.keymap_items.new('mball.duplicate_move', 'D', 'PRESS')
        kmi = km.keymap_items.new('mball.select_all', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('mball.select_all', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        km = wm.keyconfigs.addon.keymaps.new(name='Lattice', space_type='EMPTY', modal=False)
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('lattice.select_all', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        km = wm.keyconfigs.addon.keymaps.new(name='Particle', space_type='EMPTY', modal=False)
        kmi = km.keymap_items.new('particle.select_all', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('particle.select_all', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        km = wm.keyconfigs.addon.keymaps.new(name='Markers', space_type='EMPTY', modal=False)
        kmi = km.keymap_items.new('marker.duplicate', 'D', 'PRESS')
        kmi = km.keymap_items.new('marker.select_all', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('marker.select_all', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        km = wm.keyconfigs.addon.keymaps.new(name='UV Editor', space_type='EMPTY', modal=False)
        kmi = km.keymap_items.new('uv.select_all', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('uv.select_all', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        km = wm.keyconfigs.addon.keymaps.new(name='Mask Editing', space_type='EMPTY', modal=False)
        kmi = km.keymap_items.new('mask.duplicate_move', 'D', 'PRESS')
        kmi = km.keymap_items.new('mask.select_all', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('mask.select_all', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        km = wm.keyconfigs.addon.keymaps.new(name='Node Editor', space_type='NODE_EDITOR', modal=False)
        kmi = km.keymap_items.new('view2d.pan', 'MIDDLEMOUSE', 'PRESS')
        kmi = km.keymap_items.new('node.duplicate_move', 'D', 'PRESS')
        kmi = km.keymap_items.new('node.delete_reconnect', 'X', 'PRESS')
        kmi = km.keymap_items.new('wm.call_menu', 'RIGHTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'name', 'NODE_MT_add')
        kmi = km.keymap_items.new('node.view_selected', 'MIDDLEMOUSE', 'PRESS', alt=True)
        kmi = km.keymap_items.new('node.view_selected', 'MIDDLEMOUSE', 'PRESS', alt=True, shift=True)
        km = wm.keyconfigs.addon.keymaps.new(name='NLA Editor', space_type='NLA_EDITOR', modal=False)
        kmi = km.keymap_items.new('nla.properties', 'T', 'PRESS')
        kmi = km.keymap_items.new('nla.duplicate', 'D', 'PRESS')
        km = wm.keyconfigs.addon.keymaps.new(name='Sequencer', space_type='SEQUENCE_EDITOR', modal=False)
        kmi = km.keymap_items.new('sequencer.properties', 'T', 'PRESS')
        kmi = km.keymap_items.new('sequencer.select_all', 'D', 'PRESS')
        kmi = km.keymap_items.new('sequencer.select_all', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('sequencer.select_all', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        km = wm.keyconfigs.addon.keymaps.new(name='Clip Editor', space_type='CLIP_EDITOR', modal=False)
        kmi = km.keymap_items.new('clip.select_all', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('clip.select_all', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        km = wm.keyconfigs.addon.keymaps.new(name='Graph Editor', space_type='GRAPH_EDITOR', modal=False)
        kmi = km.keymap_items.new('graph.properties', 'T', 'PRESS')
        kmi = km.keymap_items.new('clip.graph_select_all_markers', 'A', 'PRESS')
        fu4(kmi.properties, 'action', 'SELECT')
        kmi = km.keymap_items.new('clip.graph_select_all_markers', 'LEFTMOUSE', 'DOUBLE_CLICK')
        fu4(kmi.properties, 'action', 'TOGGLE')
        km = wm.keyconfigs.addon.keymaps.new(name='Graph Editor', space_type='GRAPH_EDITOR', modal=False)
        kmi = km.keymap_items.new('graph.duplicate_move', 'D', 'PRESS')
        screenType = ['VIEW_3D','IMAGE_EDITOR','NODE_EDITOR', 'CLIP_EDITOR']
        screenName = ['3D View Generic','Image Generic','Node Generic', 'Clip']
        i = 0
        for st in screenType:
            sn = screenName[i]
            km = wm.keyconfigs.addon.keymaps.new(name= sn, space_type= st)
            kmi = km.keymap_items.new("object.sf_tool_shelf_quick", 'T','PRESS')
            i += 1
        addon_keymaps.append(km)
    except:
        pass
def unregister():
    bpy.utils.unregister_module(__name__)
    wm = bpy.context.window_manager
    for km in addon_keymaps:
        wm.keyconfigs.addon.keymaps.remove(km)
    del addon_keymaps[:]
if __name__ == "__main__":
    register()